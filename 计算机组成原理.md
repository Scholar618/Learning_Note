[TOC]

# 计算机组成原理

## 3 存储系统

### 3.1存储器概述

#### 3.1.1 存储器的分类

##### 1.存储介质

半导体器件、磁性材料、光盘存储器

##### 2.存取方式

随即访问存储器（RAM）：**存取时间**和**存取单元**的物理位置无关，如：半导体材料

顺序存储器：存取时间和存储单元的物理位置有关，如磁带存储器

直接访问存储器：如硬盘、光盘

##### 3.存储内容可变性

只读存储器、可读可写存储器

只读存储器（ROM）：只能读出但不能写入的半导体存储器

##### 4.信息易失性

断电后信息消失的存储器，称为易失性存储器

##### 5.系统中的作用

可分为主存储器、高速缓冲存储器、辅助存储器

##### 存储器分类举例

| **常用存储器** | **存储介质** | **存取方式** | **存储内容可变性** | **信息易失性** | **系统中的作用** |
| -------------- | ------------ | ------------ | ------------------ | -------------- | ---------------- |
| 内存条         | 半导体       | 随机         | 可读写             | 易失           | 主存             |
| 硬盘           | 磁表面       | 直接         | 可读写             | 非易失         | 辅存             |
| U盘            | 半导体       | 随机         | 可读写             | 非易失         | 辅存             |
| 光盘           | 光盘         | 直接         | 只读或可刻录       | 非易失         | 辅存             |
| 磁带           | 磁表面       | 顺序         | 可读写             | 非易失         | 辅存             |
|                |              |              |                    |                |                  |



#### 3.1.2 存储器的分级结构

1. 速度快的存储器价格贵、容量小
2. 价格低的存储器速度慢、容量大
3. 对存储器的要求是容量大、速度快、成本低，但是同时兼顾三方面很难实现
4. 为了解决这方面的矛盾，在计算机系统中，通常采用多级存储器体系结构，即使用**高速缓冲存储器（cache）**、**主存储器**和**外存储器**

##### 高速缓冲存储器

简称cache，它是计算机系统中的一个**高速**但**小容量**的**半导体存储器**

##### 主存储器

简称主存，它是计算机系统的**主要寄存器**，用来**存放**计算机运行期间的**大量程序和数据**

##### 外存储器

简称外存，它是**大容量辅助**存储器

![image-20230513121246427](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513121246427.png)

##### 他们之间的联系

![image-20230513121415996](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513121415996.png)



#### 3.1.3 主存储器的技术指标 

##### 存储容量

存储容量 = 存储单元数*存储单元位数

单位有KB、MB、GB、TB等

1KB = 2(10)B, 1MB = 2(20)B, 1GB = 2(30)B, 1TB = 2(40)B

1B = 8bit(8位)

##### 存取时间

指`一次读操作命令发出到该操作完成`，将数据读出到数据总线上所经历的时间

写时间 = 读时间，故称为存取时间

##### 存储周期

指连续启动两次读操作所需间隔的最小时间

存储周期 >= 存取时间，单位ns

##### 存储器带宽

单位时间里存储器所<u>存取的信息量</u>，通常单位为位/秒或字节/秒



### 3.2 静态存储器SRAM

#### 3.2.1 基本的静态存储元阵列

##### 静态存储元

用一个触发器作为存储元，静态是指只要直流电电源一直加在这个电路上，他就会无限期的保持记忆的1状态或0状态，如果电源断电，那么存储的数据会丢失

![image-20230513131033257](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513131033257.png)

##### 2:4译码器的设计

译码器的功能：输入n个二进制信号，输出为2n个信号，其中一个为1，其余为0

如下图就是输入2个二进制信号，输出4个信号。

![image-20230513131333111](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513131333111.png)

逻辑表达式：

![image-20230513131508501](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513131508501.png)

理论逻辑电路：

![image-20230513131530677](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513131530677.png)

#### 3.2.2 基本的SRAM逻辑结构

SRAM芯大多采用双译码方式，以便组织更大的存储容量

![image-20230513133100659](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513133100659.png)

该芯片的A线、D线分别为多少？

A线：![image-20230513133232158](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513133232158.png)

D线：8根

##### 读与写的互锁逻辑

![image-20230513133413039](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513133413039.png)

控制信号CS是片选信号，CS有效时（低电平）。

1.当CS = 1时，G1 = 0， G2 = 0， 门G1、G2均被关闭。

2.当CS = 0时，

① 如果WE=0，G1=1，G2=0，门G1打开，G2关闭，执行写操作

②如果WE=1，OE=0(OE为读出使能信号，低电平有效)，G1=0，G2=1，门G1关闭，G2打开，执行读操作。

**注意**：门G1和G2是互锁的，一个开启时另一个必定关闭，这样保证了读时不写，写时不读。



#### 3.2.3 存储器的读写周期

##### 读周期

![image-20230513134523333](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513134523333.png)

![image-20230513134526991](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513134526991.png)

在读周期中，<u>地址线先有效</u>，以便进行地址译码，选中存储单元。为了读出数据，<u>片选信号/CS和读出使能信号/OE也必须有效</u>(由高电平变为低电平)

从地址有效开始经tAQ(读出)时间，数据总线I/O上出现了有效的读出数据。

之后/CS、/OE信号恢复高电平，**tRC以后才允许地址总线发生改变**。tRC时间称为读周期时间。

##### 写周期

- 在写周期中，也是地址线先有效，接着片选信号/CS有效，写命令/WE有效(低电平)。
- 此时数据总线I/O上必须置写入数据，在tWD时间段将数据写入存储器。
- 之后撤消写命令/WE和/CS。
- 为了写入可靠，I/O线的写入数据要有维持时间thD，/CS的维持时间也比读周期长。tWC时间称为写周期时间。
- 为了控制方便，一般取tRC=tWC，通常称为存取周期。



### 3.3 动态随机存储器DRAM

#### 3.3.1 DRAM存储位元的工作原理

- SRAM存储器的存储位元是一个触发器，有两个稳定的状态
- DRAM存储器的存储元是由一个**MOS晶体管**和**电容器**组成的记忆电路

![image-20230513140347748](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513140347748.png)

#### 3.3.2  刷新操作

DRAM存储位元是基于电容器上的电荷量存储的，这个电荷量随着时间和温度而减少，因此<u>必须定期的刷新</u>，以保持它们原来记忆的正确信息。

刷新要按行进行刷新，刷新一行的时间为一个**读周期**（即存储周期）。

如图：一个存储周期刷新一行可以为1024 X 4位个存储元进行刷新

![image-20230513141028761](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513141028761.png)

##### 两种刷新操作

1.集中式刷新：DRAM的所在行在每一个刷新周期中都被刷新

![image-20230513141253030](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513141253030.png)

2.分散式刷新：每一行的刷新插入到正常的读/写周期之中

![image-20230513141306552](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513141306552.png)

#### 3.3.3 存储器容量的扩充

##### 1.位扩展

假设使用8K×1位的RAM芯片，组成8K×8位的存储器

1.计算所需芯片数：

d = 8K×8位 / 8K×1位 =8 （片）

2.要组成8K×8位的存储器，CPU的A线数=㏒28K=13根，D线数=8根  

   使用8K×1位的RAM芯片，芯片的A线数=㏒28K=13根，D线数=1根

 3.画出CPU与芯片的连接 

##### 2.字扩展

假设使用16K×8位的RAM芯片，组成64K×8位的存储器

1.计算所需芯片数：

  d =64K×8位 / 16K×8位 =4 （片）

2.要组成64K×8位的存储器，CPU的A线数=㏒264K=16根，D线数=8根

   使用16K×8位的RAM芯片，芯片的A线数=㏒216K=14根，D线数=8根

 3.画出CPU与芯片的连接 

##### 3.位字同时扩展

1.计算所需芯片数：

   d =M X N/(K X L)

2.CPU的A线数=㏒2M，D线数=N

​    芯片的A线数=㏒2K，D线数=L

3.画出存储器芯片，N/L为一组，一共M/K组，并给出相应的编号

4.连接数据线、地址线、控制线

例如：

用16K×1位的DRAM芯片工程64K×8位存储器，要求画出该存储器的组成逻辑框图

(1)d=64K×8位 / 16K×1位 =32片
      8片一组，一共4组
      CPU的A线16根，D线8根
      芯片的A线14根，D线1根

![image-20230513143800021](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230513143800021.png)



### 3.4 只读存储器和闪速存储器

#### 3.4.1 只读存储器

掩模ROM：掩模ROM实际上是一个存储内容固定的ROM，由生产厂家提供产品。

可编程ROM：用户后写入内容，有些可以多次写入。

> 一次性编程的PROM（紫外线擦除PROM）
> 多次编程的EPROM和E2PROM（电擦除）

#### 3.4.2 Flash存储器

Flash存储器又称为闪速存储器，它是高密度非失易失性的读/写存储器，既有RAM的优点又有ROM的优点

| **常用存储器** | **存储介质** | **存取方式** | **存储内容可变性** | **信息易失性** | **系统中的作用** |
| -------------- | ------------ | ------------ | ------------------ | -------------- | ---------------- |
| 掩模ROM        | 半导体       | 随机         | 只读               | 非易失         | 主存(BIOS)       |
| EPROM          | 半导体       | 随机         | 可读写             | 非易失         | 主存(BIOS)       |
| EEPROM         | 半导体       | 随机         | 可读写             | 非易失         | 主存(BIOS)       |
| Flash          | 半导体       | 随机         | 可读写             | 非易失         | 辅存(U盘)        |



### 3.5 并行存储器

​    由于CPU和主存储器之间在速度上是不匹配的，这种情况便成为限制高速计算机设计的主要问题。为了提高CPU和主存之间的数据传输率，除了主存采用更高速的技术来**缩短读出时间**外，还可以采用**并行技术的存储器**。

#### 3.5.1 双端口存储器

##### 1.双端口存储器的逻辑结构

双端口存储器由于同一个存储器具有两组相互独立的读写控制电路而得名。由于进行并行的独立操作，因而是一种高速工作的存储器。



##### 2. 无冲突读写控制

​     当两个端口的地址不相同时，在两个端口上进行读写操作，一定不会发生冲突。当任一端口被选中驱动时，就可对整个存储器进行存取，每一个端口都有自己的片选控制(CE)和输出驱动控制(OE)。读操作时，端口的OE(低电平有效)打开输出驱动器，由存储矩阵读出的数据就出现在I/O线上。



##### 3. 有冲突读写

​      当两个端口同时存取存储器同一存储单元时，便发生读写冲突。为解决此问题，特设置了BUSY标志。在这种情况下，片上的判断逻辑可以决定对哪个端口优先进行读写操作，而对另一个被延迟的端口置BUSY标志(BUSY变为低电平)，即暂时关闭此端口。

![image-20230514153133663](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230514153133663.png)



#### 3.5.2 多模块交叉存储器

一个由若干个模块组成的主存储器是线性编址的。这些地址在各模块中如何安排，有两种方式：一种是**顺序方式**，一种是**交叉方式**。

##### 顺序方式

![image-20230514192257865](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230514192257865.png)

M0：0-7，M1：8-15，M2：16-23，M3：24-31

例如：
当地址A = 27D = *11* *011*B时，则访问M3模块，块内地址第三个字

##### 交叉方式

![image-20230514192553948](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230514192553948.png)

M0：0，4......除以4余数为0
M1：1，5......除以4余数为1
M2：2，6......除以4余数为2
M3：3，7......除以4余数为3
模块号 = A mod 模块数

例如：
当地址A = 26D = *110* *10*B时，则访问M2模块，块内地址第六个字

##### 特点

顺序方式：通过增添模块来扩充存储器容量比较方便。缺点是各模块串行工作，存储器的带宽受到了限制。

交叉方式：连续地址分布在相邻的不同模块内，同一个模块内的地址都是不连续的。优点是对连续字的成块传送可实现多模块流水式并行存取，大大提高存储器的带宽。使用场合为成批数据读取。



### 3.6 Cache存储器

#### 3.6.1 cache基本原理

解决CPU和主存之间的速度不匹配问题。

Cache的设计依据:CPU这次访问过的数据，下次有很大的可能也是访问附近的数据。（程序局部性原理）

![image-20230516141127709](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230516141127709.png)

##### CPU的读操作

*主存与Cache之间的数据传送是以块为单位*

CPU读主存时，便把地址同时送给Cache和主存，Cache控制逻辑依据地址判断此字是否在Cache中。如果在Cache中，则为命中，不在，则为缺失（未命中）

读命中：数据立即传送给CPU 。

未命中：则用主存读周期把此字从主存读出送到CPU，与此同时，把含有这个字的整个数据块从主存读出送到cache中。

##### Cache的命中率

在一个程序执行期间，设Nc表示cache完成存取的总次数，Nm表示主存完成存取的总次数，h定义为命中率，则有:
①h=Nc/（Nc+Nm）

若tc表示命中时的cache访问时间，tm表示未命中时的主存访问时间，1-h表示未命中率，则cache/主存系统的平均访问时间ta为：（同时访问）
②ta=h*tc +（1-h）tm
（不同时访问）
③ta=h*tc + (1-h)(tm + tc);

e表示访问效率，则有：
④e = tc/ta = 1/(r+(1-r)*h)
设r=tm/tc表示主存慢于cache的倍率，r值以5—10为宜，不宜太大。由表达式看出，为提高访问效率，命中率h越接近1越好。

h表示命中率，则有：
①h = Nc/（Nc+Nm)
平均访问时间：
②ta = h*tc + （1-h）tm
e表示访问效率
③e = tc/ta

##### 有待解决的问题

如何区分Cache与主存的数据块对应关系？（Cache和主存的映射方式）
Cache很小，主存很大，如果Cache满了怎么办？（替换算法）
CPU修改了Cache中的数据副本，如何确保主存中数据母本的一致性（Cache写策略）

![image-20230516144944917](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230516144944917.png)

#### 3.6.2 主存与Cache的地址映射

Cache块中也包含由主存块的内容副本，那么我们要如何区分Cache与主存之间数据块的对应关系呢？

![image-20230516151437309](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230516151437309.png)

在对应Cache的位置放一个标记和有效位，标记指的是对应主存块号的标记，有效位指的是1或0，表示标记是否有效。

假设某个计算机的主存地址空间大小是256MB（地址位数28位），按字节编址，其数据Cache有8个Cache行，行长为64B（块内地址6位）

![image-20230516154805016](D:\Typora\pictures\image-20230516154805016.png)![image-20230516155128221](D:\Typora\pictures\image-20230516155128221.png)

主存块号：22位， 块内地址：6位

##### 全相联的映射方式

主存块可以存放在Cache的任意位置。

![image-20230516151759896](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230516151759896.png)

CP要访问主存地址1...1101 001110步骤：

1. 主存地址的前22位，对比Cache中所有块的标记
2. 若标记匹配且有效位=1，则Cache命中，访问块内地址为001110的单元
3. 若未命中或有效位=0，则正常访问主存

优点：

可以灵活的利用Cache的空间，避免直接映射和组相联映射的冲突

缺点：

难以设计和实现，因此只适用于小容量cache采用

##### 直接映射方式

每个主存块只能放到一个特定的位置：Cache块号 = 主存块号%Cache总块数

![image-20230516151917149](C:\Users\Schloar\AppData\Roaming\Typora\typora-user-images\image-20230516151917149.png)

主存块号%2^3相当于留下最后三位二进制数

这个标记只需要19位进行优化，后面3位不需要了

CPU要访问0…01000 001110步骤：

1. 根据主存块号的后3位确定Cache行
2. 若主存块号的前19位与Cache标记匹配且有效位=1，则Cache命中，访问块内地址位001110的单元
3. 若未命中或有效位=0，则正常访存主存

优点：

硬件简单，成本低，地址变换速度快

缺点：

每个主存块只有一个固定的行位置可存放，可能会出现冲突

##### 组相联映射方式

Cache块分为若干组，每个主存块可以放到分组中的任意位置，组号 = 主存块号%分组数

![image-20230516152344269](D:\Typora\pictures\image-20230516152344269.png)

主存块%2^2，相当于留下最后两位

这个标记只需要20位进行优化，后面2位不需要了

CPU要访问1…1101 001110步骤：

1. 根据主存块号的后2位确定所属分组号
2. 若主存块号的前20位与分组内的某个标记匹配且有效位=1，则Cache命中，访问块内单元地址位001110的单元
3. 若未命中或有效位=0，则正常访存主存

优点：

可以一定程度上避免直接映射的冲突，相对于全相联映射实现更为简单

缺点：

相对于全相联映射，仍然存在冲突的情况，从而导致命中率降低

![image-20230516163502034](D:\Typora\pictures\image-20230516163502034.png)

![image-20230516161017207](D:\Typora\pictures\image-20230516161017207.png)



#### 3.6.3 替换算法

Cache很小，主存很大，但是每次被访问的主存块一定会被立即调入Cache中，那如果Cache满了怎么办？

这个时候就要用到替换算法了，下面用三种不同的映射方式来对比替换算法的作用。

全相联映射：因为访问主存块后会放到Cache的任意一个位置，所以只有等Cache完全满了才需要替换，而且需要在全局中选择替换哪一块

直接映射：因为访问主存块后会放到Cache的固定位置，所以当对应位置非空，则毫无疑问的直接替换

组相联映射：因为访问主存块后会放到Cache分组内，所以只有当分组内满了才需要替换，而且需要在分组内选择替换哪一块

**替换算法只会在全相联映射和组相联映射中考虑**，直接映射不需要考虑替换算法（每次都必替换就不需要考虑了）

设总共有4个Cache块，初始整个Cache是空的，采用全相联映射，依次访问主存块{1,2,3,4,1,2,5,1,2,3,4,5}

##### 随机算法（RAND）

随机算法（RAND，Random）：若Cache已满，则随机选择一块进行替换

![](D:\Typora\pictures\image-20230516171310208.png)

实现简单，但完全没考虑局部性原理，命中率低，实际效果很不稳定。



##### 先进先出算法（FIFO）

先进先出算法（FIFO，First in First Out）：若Cache已满，则替换最先被调入Cache的块

![image-20230516172208509](D:\Typora\pictures\image-20230516172208509.png)

实现简单，最开始按照顺序依次放入Cache，之后也按照顺序轮流替换
但是，FIFO也没考虑局部性原理，命中率也较低，最先被调入Cache的块也有可能是被频繁访问的，会出现<u>抖动现象</u>

抖动现象：频繁的换入换出现象（刚被替换掉的块紧接着又被调入）



##### 近期最少使用算法（LRU）

近期最少使用算法（LRU，Least Recently Used）：为每一个Cache块设置一个”计数器“，用于记录每个Cache块已经有多久**没有被访问**了，当Cache满后替换”计数器“最大的那个。

![image-20230516173621439](D:\Typora\pictures\image-20230516173621439.png)

计数器规则：

1. 命中时，所命中的行的计数器清零，比其他比其低的计数器加1，其余不变
2. 未命中且还有空闲行时，新装入的行的计数器置0，其余**非空闲行**全加1
3. 未命中且无空闲行时，计数值最大的行的信息块被淘汰，新装入的块的计数器置0，其余全加1

基于”局部性原理“，近期访问过的主存块，在不久的将来也有可能被再次访问，因此淘汰最久没被访问过的块是合理的。LRU算法的实际运行效果很优秀，Cache命中率最高。

若被频繁访问的主存块数量>Cache行的数量，则也有可能发生抖动，如{1,2,3,4,5,1,2,3,4,5,1,2,…}



##### 最不经常使用算法（LFU）

最不经常使用算法（LFU， Least Frequently Used）：为每一个Cache块设置一个”计数器“，用于记录每个Cache块被**访问过几次**，当Cache满后替换”计数器“最小的那个

![image-20230516174712349](D:\Typora\pictures\image-20230516174712349.png)

计数器规则：

新调入的块计数器=0，之后每被访问一次计数器+1，需要替换时，选择计数器最小的一行。

基于”局部性原理“，曾经被经常访问的主存块在未来不一定会用到（如与微信视频聊天相关的块）并没有很好的遵循局部性原理，因此实际运行效果不如LRU



![image-20230516165628373](D:\Typora\pictures\image-20230516165628373.png)



#### 3.6.4 写策略

CPU修改了Cache中的数据副本，那么如何确保主存中的数据母本的一致性？

这时候我们讨论写策略来保证一致性，分为两种情况：

写命中：

- 全写法
- 写回法

写不命中：

- 写分配法
- 非写分配法

##### 写命中

###### 写回法

当CPU对Cache命中时，只修改Cache的内容，而不立即写入主存，只有当此块被换出时才写回主存

增加一个脏位来表示是否被修改，如果被修改，将Cache行写入主存保证一致性。

![image-20230517164710399](D:\Typora\pictures\image-20230517164710399.png)

减少了访存次数，但存在数据不一致的隐患

###### 全写法

又叫写直通法，当CPU对Cache写命中时，必须把数据同时写入Cache和主存，一般使用写缓冲（Write buffer）

![image-20230517164942862](D:\Typora\pictures\image-20230517164942862.png)

访问次数增加，速度变慢，但能保证数据一致性

当使用写缓冲时，CPU写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁，可能会因为写缓冲饱和而发生阻塞

##### 写不命中

###### 写分配法

当CPU对Cache写不命中时，把主存中的块调入Cache，在Cache中进行修改，通常搭配写回法使用

###### 非写分配法

当CPU对Cache写不命中时只写入主存，不调入Cache，只有“读”未命中才会调入Cache，搭配全写法使用



##### 多级Cache

现代计算机通常采用多级Cache

离CPU越近的速度越快，容量越小
离CPU越远的速度越慢，容量越大

![image-20230517170201864](D:\Typora\pictures\image-20230517170201864.png)



### 3.7 虚拟存储器

#### 3.7.1 页式存储器

主存与Cache之间是由块作为单位进行传递

页式存储系统：一个进程在逻辑上被分为若干个大小相等的“页面”，“页面”大小与“块”的大小相同，每个页面可以离散地放入不同的主存块中

逻辑地址（虚地址）：程序员视角看到的地址
物理地址（实地址）：实际在主存中的地址

CPU执行的机器指令中，使用的是“逻辑地址”，因此需要通过“页表”将逻辑地址转为物理地址。

页表的作用：记录了每个逻辑页面存放在哪个主存块中

##### 地址变换过程

![image-20230517181748987](D:\Typora\pictures\image-20230517181748987.png)





## 4 指令系统

### 4.1 指令格式

#### 定义

一条指令在逻辑上可以被划分为操作码和地址码两个部分组成，

操作码指明了：用户想要干什么
地址码指明了：对谁进行操作

#### 按地址指令数目分类

一条指令的地址码有0~4个，所以可以分成4种指令

##### 零地址指令

1. 不需要操作数，如空操作、停机、关中断等指令

2. 堆栈计算机，两个操作数隐含存放在栈顶和次栈顶，计算结果压回栈顶

##### 一地址指令

1. 只需要单操作数，如加1、减1、取反、求补等

   指令含义：OP(A1)->A1

   完成一条指令需要3次访存：取指->读A1->写A1

2. 需要两个操作数，但其中一个操作数隐含在某个寄存器中（如隐含在ACC）

   指令含义：(ACC)OP(A1)->ACC

   完成一次指令需要2次访存：取指->读A1

注：A1指某个主存地址，(A1)表示A1所指向的地址中的内容

##### 二地址指令

常用于需要两个操作数的算术运算、逻辑运算相关指令

指令含义：(A1)OP(A2)->(A1)

完成一条指令需要访存4次，取指->读A1->读A2->写A1

##### 三地址指令

常用于需要两个操作数的算术运算、逻辑运算相关指令

指令含义：(A1)OP(A2)->A3

完成一条指令需要访存4次，取指->读A1->读A2->写A3



#### 按指令长度分类

指令字长：一条指令的总长度(可能会变)

机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（通常与ALU直接相关）

存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同）



半字长指令、单字长指令、双字长指令				----指令长度是机器字长的多少倍

指令字长会影响取指令所需时间。如：机器字长=存储字长=16bits,则取一条双字长指令需要里那个粗访存。



定长指令字结构：指令系统中所有指令的长度都相等

变长指令字结构：指令系统中各种指令的长度不等



#### 按操作码长度分类

定长操作码：指令系统中的所有指令的操作码长度都相同

​	控制器的译码电路设计简单，但灵活性较差

可变长操作码：指令系统中各指令的操作码长度可变

​	控制器的译码电路设计复杂，但灵活性较高

定长指令字结构+可变长操作码 -> 扩展操作码指令格式



#### 按操作类型分类

可以i分成4种大类型：数据传送类、运算类（算术逻辑操作和移位操作）、程序控制类、输入输出类。

数据传送类：进行主存与CPU之间的数据传送

运算类：进行运算

程序控制类：改变程序执行的顺序

输入输出类：进行CPU和I/O设备之间的数据传送

##### 1.数据传送

​	LOAD  作用：把存储器中的数据放到寄存器中
​	STORE  作用：把寄存器中的数据放到存储器中

##### 2.算术逻辑操作

​	算术：加、减、乘、除、增1、减1、求补、浮点运算、十进制运算
​	逻辑：与、或、非、异或、位操作、位测试、位清除、位求反

##### 3.移位操作

​	算术移位、逻辑移位、循环移位（带进位和不带进位的）

##### 4.转移操作

无条件转移 JMP
条件转移  JZ：结果为0；JO：结果溢出；JC：结果有进位
调用和返回 CALL和RETURN
陷阱（Trap）与陷阱指令

##### 5.输入输出操作

CPU寄存器与IO端口之间的数据传送（端口即IO接口中的寄存器）



![image-20230521133001310](D:\Typora\pictures\image-20230521133001310.png)



### 4.1.2 扩展操作码指令格式

定长指令字结构+可变长操作码->扩展操作码指令格式

不同地址数的指令使用不同长度的操作码

#### 扩展操作码举例

指令字长16位，每一个地址码占4位

太难了，直接做题吧。



### 4.2.1 指令寻址

指令寻址：如何确定下一条指令的存放地址？

有两种方式：顺序寻址、跳跃寻址

顺序寻址：(PC) + "1" -> PC
1可以理解为1个指令字长，实际加的值会因指令长度、编制方式而不同

跳跃寻址：执行转移类指令会导致PC值改变

![image-20230521144101130](D:\Typora\pictures\image-20230521144101130.png)



### 4.2.2 数据寻址

数据寻址：确定本条指令的地址码指明的真实地址

![image-20230521144634590](D:\Typora\pictures\image-20230521144634590.png)

前面会放4个比特位，来确定使用哪种寻址方式

例如一地址指令：

![image-20230521144729987](D:\Typora\pictures\image-20230521144729987.png)

假设指令字长=机器字长=存储字长，操作数为3

具体的寻址方式看书

#### 偏移寻址

分为基址寻址、变址寻址、相对寻址

基址寻址：以程序的起始存放地址作为“起点”    EA = (BR) + A
变址寻址：程序员自己决定从哪里作为“起点”    EA = (IX) + A
相对寻址：以程序计数器PC所指地址作为“起点”  EA = (PC) + A

##### 基址寻址

将CPU中的基址寄存器(BR)的内容加上指令格式中的形式地址A，而形成操作数的有效地址，即EA=(BR) + A

优点：便于程序“浮动”，方便实现多道程序并发运行

##### 变址寻址

有效地址EA等于指令字中的形式地址A与变址寄存器IX的内容相加之和，即EA=(X) + A,其中IX为可变址寄存器（专用），也可用通用寄存器作为变址寄存器





堆栈寻址：操作数存放在堆栈中，隐含使用堆栈指针(SP)作为操作数寻址

![image-20230521154505046](D:\Typora\pictures\image-20230521154505046.png)



## 5 中央处理器

### 5.1  CPU功能和结构

CPU需要具有以下五方面的功能：

指令控制、操作控制、时间控制、数据加工、<u>中断处理</u>

指令控制：程序执行顺序控制
操作控制：一条指令由若干个操作信号实现
时间控制：各种操作实施时间的定时
数据加工：算术运算和逻辑运算

控制器基本结构：程序计数器、指令寄存器、指令译码器、时序产生器、操作控制器

![image-20230604130709288](D:\Typora\pictures\image-20230604130709288.png)

程序计数器（PC）：用来存放正在执行指令的地址或者将要执行的下一条指令地址

- 顺序执行时，每执行一条指令，PC的值要加1
- 要<u>改变程序执行顺序</u>，一般由转移类指令将转移目标地址送往PC，实现程序的转移

指令寄存器（IR）：用来存放从存储器中取出的待执行的指令

- 在执行该指令的过程中，指令寄存器的内容不允许发生变化，以保证实现指令的全部功能

指令译码器（ID）：暂存在指令寄存器中的指令只有在其操作码部分经译码后识别出一条什么样的指令

- 译码器经过对指令进行分析和解释，产生相应的控制信号提供给时序发生器和操作控制器

时序发生器：产生节拍电位、节拍脉冲等时序信号

操作控制器：产生微操作控制信号，它是控制器的核心部件



![image-20230603133219036](D:\Typora\pictures\image-20230603133219036.png)



运算器基本结构：算术逻辑单元（ALU）、通用寄存器、数据缓冲寄存器、程序状态子寄存器

数据缓冲寄存器（DR）：暂存ALU单元的运算结果、存储器读出的数据和I/O接口的数据

数据地址寄存器（AR）：暂存CPU所访问的数据cache的地址或内存的地址

通用寄存器（R0~R3）：暂存参加运算的数据或中间结果

状态子寄存器（PSW）：保证ALU运算后的各种条件标志，如溢出，进位，符号，运算结果为零等。

![](D:\Typora\pictures\image-20230603132757161.png)

CPU的基本结构：运算器+控制器

![image-20230603133339856](D:\Typora\pictures\image-20230603133339856.png)

#### 5.1.1 操作控制器和时序发生器

通常把许多寄存器之间传送信息的通路称为**数据通路**

在各寄存器之间建立数据通路的任务，是由称为**操作控制器**的部件来完成的

<u>操作控制器的功能</u>：根据指令操作码和时序信号，产生各种操作控制信号，以便正确的完成地选择数据通路，把有关数据打入到一个寄存器，从而完成取指令和执行指令的控制

根据设计不同，操作控制器可分为<u>时序逻辑型</u>和<u>存储逻辑型</u>两种，第一种称为**硬件布线控制器**，另一种称为**微程序控制器**

- 硬件布线控制器：采用时序逻辑技术实现
- 微程序控制器：采用存储逻辑来实现

操作控制器产生的控制信号必须定时，为此必须要时序产生器

时序产生器作用：对各种操作信号实施时间上的控制

### 5.2 指令周期

![image-20230604142153204](D:\Typora\pictures\image-20230604142153204.png)

指令周期：CPU从主存中每取出并执行一条指令所需的全部时间

通常把一个指令周期划分为若干个机器周期，每个机器周期完成一个基本操作

指令周期常常用若干机器周期来表示，机器周期又叫CPU周期

一个机器周期又包含若干个时钟周期（也称节拍、T周期或CPU时钟周期，它是CPU操作的**最基本单位**）

**T周期**

在一个机器周期内，要完成若干个微操作，这些微操作有的可以同时执行，有的需要按照先后次序串行执行，因而要把一个机器周期分成若干个相等的时间段，每一个时间段称为一个**节拍**

节拍的宽度取决于CPU完成一次基本微操作的时间，如ALU完成一次正确的运算，寄存器间的一次数据传送。

**五条指令及其含义**

![image-20230604143619840](D:\Typora\pictures\image-20230604143619840.png)

程序执行前（R0）=00，（R1）=10， （R2）=20，（R3）=30

- 101：传送指令MOV执行（R1）->R0
- 102：取数指令LAD从数存6号单元取数（100）->R1
- 103：加法指令ADD执行（R1）+（R2）->R2，结果为（R2）=120
- 104：存数指令STO用（R3）间接寻址，（R2）=120写入数存30号单元
- 105：转移指令JMP改变程序执行顺序到101号单元
- 106：逻辑乘AND指令执行（R1）·（R2）->R3

#### MOV指令周期

是RR型指令，需要两个CPU周期，其中取周期需要一个CPU周期，执行周期需要一个CPU周期，具体见课本

#### LAD指令周期

是RS型指令，它先从指令寄存器取出指令，然后从数据存储器6号单元取出数据100装入通用寄存器R1，R1被替换为100，一次访问指存，一次访问数存，LAD指令的指令周期需要3个CPU周期。

#### ADD指令周期

是RR型指令，在运算器中用俩寄存器R1和R2的数据进行加法运算指令周期只需两个CPU周期，其中一个是取指周期，一个是执行周期

#### STO指令周期

是RS型指令，先访问指存取出STO指令，然后按（R3）=30地址访问数存，将（R2）=120写入到30号单元，一次访问指存，一次访问数存，因此指令周期需要3个CPU周期，其中执行周期有两个。

#### JMP指令周期

JMP是一条无条件转移指令，用来改变程序的执行顺序，指令周期为两个CPU周期。

### 5.3 时序产生器和控制方式

计算机之所以能够准确、迅速、有条不紊的工作，正是因为在CPU中有一个**时序产生器**

在CPU周期中，时间又被分成若干小段，以便规定在这若干小段中，计算机应该干什么，给计算机提供工作所需的时间标志，为此，需要采用**多级时序体系**

#### 时序信号产生器

**时钟源**

**环形脉冲发生器**

**节拍脉冲和存储器读/写时序**

**启停控制逻辑**

#### 控制方式

控制不同操作序列时序信号的方法，称作控制器的控制方式，常见的有同步控制、异步控制、联合控制三种方法

##### 同步控制方式

在任何情况下，已定指令在执行时所需要的<u>机器周期数和时钟周期数</u>都是都是<u>固定不变</u>的，称为同步控制方式

根据不同情况，可选取以下方案

- 完全统一的机器周期执行各种不同的指令
- 采用不定长机器周期
- 中央控制与局部控制结合

##### 异步控制方式

每条指令、每个操作控制信号需要多长时间就占用多长时间

使用这种方法没有固定的CPU周期数或严格的时钟周期与之同步

##### 联合控制方式

为同步控制和异步控制相结合方式

大部分指令在固定的周期内完成，少数难以确定的操作采用异步方式

机器周期的节拍脉冲固定但是各指令的机器周期数不固定

### 5.4 微程序控制器

基本思想：仿照通常的解题程序的方法，把操作控制信号编成所谓的“微指令”，存放到一个只读存储器中，当机器运行时，一条又一条的读出这些微指令，从而产生全机所需要的各种操作控制信号，使相应部件执行所规定的操作

#### 5.4.1 微指令控制原理

**1.微指令和微操作**

控制部件通过控制线向执行部件发出各种控制命令，通常把这种<u>控制命令</u>叫做“微命令”，而执行部件接受微命令后所进行的<u>操作</u>，叫做“微操作”

微命令是控制计算机各部件完成某个基本微操作的命令，微操作是执行部件中最基本的操作

**微操作的分类**

根据数据通路的结构关系，微操作可以分为相容的和相斥的两种

相容的微操作：是指能够同时或在同一个CPU周期内并行执行的微操作，必须各占一位

相斥的微操作：是指不能在同时或不能在同一个CPU周期内并行执行的微操作

**2.微指令和微程序**

把在同一CPU周期内并行执行的微操作控制信息，存储在控制存储器里，称为一条微指令

微指令由操作控制和顺序控制两大部分组成：

①操作控制字段，又称为操作码字段，用以产生某一步操作所需的各个微操作控制信号

②顺序控制字段，又称为微地址码字段，用以控制下一条要执行的微指令地址

## 6 总线

### 6.1 总线的概述

#### 6.1.1 总线的定义

总线是一组能为多个部件<u>分时</u><u>共享</u>的公共信息传送线路

共享：指总线上可以挂接多个部件，各个部件之间相互交换的信息都可以通过这组线路分时共享

分时：指同一时刻只允许有一个部件向总线发送信息，如果系统中有多个部件，则它们只能分时地向总线发送信息



### 6.2 总线的特性及性能指标

**总线特性：**

机械特性、电气特性、功能特性、时间特性

机械特性：尺寸、形状、管脚数及排列顺序
电气特性：传输方向和有效的电平范围
功能特性：每根传输线的功能（地址、数据、控制）
时间特性：信号的时序关系

**总线的性能指标：**

总线带宽、标准传输率、时钟同步/异步、总线复用、信号线数、总线控制方式、其他指标

总线宽度：数据线的根数
标准传输率：每秒传输的最大字节数（MBps）
时钟同步/异步：同步、不同步
总线复用：地址线与数据线复用
信号线数：地址线、数据线和控制线的总和
总线控制方式：突发、自动、仲裁、逻辑、计数
其他指标：负载能力

**总线结构**

单总线结构：使用单一的系统总线来连接CPU、主存和IO设备，称为单总线结构

多总线结构：

双总线结构：

![](D:\Typora\pictures\image-20230603160740162.png)

**总线带宽**

总线带宽定义：总线本身能达到的最高的传输速率，是衡量总线性能的重要指标

总线的一次信息传送过程，大致可分为五个阶段：请求总线、总线仲裁、寻址、信息传送、状态返回（一个总线周期）

如何提高总线带宽？
提高总线宽度、提高总线时钟频率

**总线的内部结构**

地址线：是单向的，用来传送主存与设备的地址

数据线：是双向的，用来传送数据

控制线：对每一根线是单向的（CPU发向接口，或接口发向CPU），用来指明数据传送方向（存储器读、存储器写、IO读、IO写），中断控制和定时控制等。

### 6.3 总线接口

#### 6.3.1 信息传递方式

##### 串行传送

使用一条传输线，采用脉冲传输

主要优点：只需要一条传输线，对于长距离的传输效果较为明显，不管多远，只需要一条传输线，成本较低

**并行传送**

每一个数据位都需要一条传输线，一般采用电位传送



#### 6.3.2 总线接口基本概念

![image-20230603172805196](D:\Typora\pictures\image-20230603172805196.png)

**I/O接口**：也叫适配器，是CPU和主存、外设之间通过系统总线进行连接的逻辑部件。

接口功能：

控制：靠指令信息控制外围设备，如启动关闭等

缓冲：外围设备与CPU之间的缓冲器，补偿速度差异

状态：监视外围设备的工作状态并保存，供CPU询问外围设备时进行分析

转换：可以完成任何要求的转换，如并-串转换成串-并

整理：在需要时可以修改字计数器或当前内存地址寄存器。

程序中断：外围设备向CPU请求某种动作时，接口模块即发送一个请求中断信号到CPU



### 6.4 总线仲裁

概念：连接到总线上的功能模块有<u>主动</u>和<u>被动</u>两种形态，其中主方可以启动一个总线周期，而从方只能响应主方请求。每次总线操作，只能有一个主方，但是可以有多个从方。

按照总线仲裁电路的位置不同，仲裁方式分为集中式和分布式两种。

#### 集中式仲裁

每个功能都会有两条线连到总线控制器，一条送到仲裁器的总线请求信号线<u>BR</u>，一条送到仲裁器的总线授权信号线<u>BG</u>

##### 1.链式查询方式

![image-20230603175021136](D:\Typora\pictures\image-20230603175021136.png)

工作过程：

- 设备接口向公共的BR线发出总线请求
- 当总线不忙时，总线仲裁器发出BG信号
- 总线同意信号BG串行的从一个IO接口传到下一个IO接口，假如BG到达的接口无总线请求，则继续向下查询，反之，不向下查询，并获得了总线控制权，同时将总线设置为“忙”

优点：只用很少的几根线就能按一定优先次序实现总线仲裁，并且这种链式结构很容易扩充设备

缺点：对询问链的电路比较敏感，优先级固定

##### 2.计数器定时查询方式

![](D:\Typora\pictures\image-20230603180101245.png)

工作过程：

- 总线上任意一个设备要求使用总线时，通过BR线发出总线请求
- 总线仲裁器接到请求后，在BS线为0的情况下让计数器开始计数，计数器通过设备地址线发向各设备
- 每个设备接口都有一个设备接口判别电路，当地址线上的数值与请求总线上的设备地址相一致时，该设备置“1”BS线，获得了总线使用权，此时中止计数查询

##### 3.独立请求方式

![](D:\Typora\pictures\image-20230603181023752.png)

工作过程：

- 当设备要求使用总线时，便发出该设备的请求信号
- 总线仲裁器中有一个排队电路，它根据一定的优先次序决定首先响应哪个设备的请求，给设备以授权信号BGi

优点：响应时间快，对优先次序的控制相当灵活



#### 分布式仲裁

不需要总线仲裁器，每个潜在的主方模块都有自己的仲裁号和仲裁器。



### 6.5 总线的定时和数据传送模式

#### 6.5.1 总线的定时

一个总线周期等于若干个总线时钟周期。

##### 1.同步定时

同步定时协议中，事件出现在总线上的时刻由总线时钟信号来确定。由于采用了公共时钟，每个功能模块什么时候发送或接收信息都由统一时钟规定，因此，同步定时具有较高的传输频率。

同步定时适用于总线长度较短、各功能模块存取时间比较接近的情况

##### 2.异步定时

在异步定时协议中，后一事件出现在总线上的时刻取决于前一事件的出现，即建立在应答式或互锁机制基础上。在这种系统中，不需要统一的共公时钟信号。总线周期的长度是可变的。

优点：总线周期长度可变，不把响应时间强加到功能模块上，因而允许快速和慢速功能模块连接到同一总线上。



#### 6.5.2 总线数据传送模式

（1）读、写操作：读操作是由从方到主方的数据传送，写操作是由主方到从方的数据传送。

（2）块传送操作：给出块的起始地址，然后对固定块长度的数据一个接一个地读出或写入，对于CPU（主方）存储器（从方）而言的块传送，常称为猝发式传送

（3）写后读、读修改写操作：写后读只给出地址一次，进行先写后读操作，用于校验目的；读修改写进行先读后写操作，用于多道程序
系统中对共享存储资源的保护

（4）广播、广集操作：一般而言，数据传送只在一个主方和一个从方之间进行。但有的总线允许一个主方对多个从方进行写操作，这种操作称为广播。与广播相反的操作称为广集，它将选定的多个从方数据在总线上完成AND或OR操作，用以检测多个中断源。



### 小结：

![image-20230603183428979](D:\Typora\pictures\image-20230603183428979.png)

![image-20230603183439996](D:\Typora\pictures\image-20230603183439996.png)





## 7 外围设备















